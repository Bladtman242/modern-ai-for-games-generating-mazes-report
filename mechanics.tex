\section{Game Mechanics}
\label{sec:mechanics}
%How does the game work that you are using? Why do you need AI in this game?

The algorithm is not designed towards any specific game or game mechanics, but it is worth discussing how different mechanics will affect how the algorithm should be configured. 

This section will go through a few examples of some familiar game mechanics and what metrics can help determine if a level is suited for a game with such mechanics. For every point, it is worth keeping in mind that the criteria will hugely depend on the specific game mechanics.

\subsection{Cops and Robbers}

The first broad category we'll discuss is cops and robbers games. Some specific genres in this category are stealth, heist, and horror games, and some arcade games, such as Pacman, in which you have to avoid enemies while reaching your goal.

Some of the key metric in evaluating if a level is good for cops and robbers are cul-de-sacs and cycles. The effect of each depends highly on the specific game mechanics, but in general, we want cyclic levels with multiple cycles and a few dead ends to place objectives at.

Cul-de-sacs are not encouraged because they can easily guarantee a loss for the player if they are caught there. A few short dead ends are useful for placement of objectives or as red herrings. 

Inversely cycles are an advantage for the player, as it ensures that they have an escape route. If the game has limited visibility, then cycles work even better because the player can still run into the cops if they don't know they're there.


\subsection{Dungeon Crawlers}

The second category we will work with is dungeon crawlers. Examples of these are the Zelda games, Binding of Issac, and Skyrim.

The key metrics this time around are cycles and choke-points. Dungeons typically have branching paths and few cycles. Any cycles are typically used for backtracking. Choke-points are important for placing objectives, such as locked doors and help make the dungeon more linear.

Choke-points is a very important metric for dungeon crawlers, but with all the other metrics, that look for trees and dead-ends, which are similar to choke-points, it can easily be redundant. We define them as an edge in the graph that connects two otherwise separated components. To gain some performance we chose to hope that choke-points would arise from other metrics, especially cycles.

Cycles will not improve a classic dungeon since dungeons need a clear branching tree structure to allow for progression. We can easily detect how much of a graph is cycles by comparing the size of the subtrees in the graph to the overall size of the graph. Subtrees are by definition the inverse of the cycles in a graph because any part of the graph that is not cyclic is a subtree or a portion of one.


\subsection{Theme and style}

There are a lot of features that are left to the theme and style of the game. Symmetry, for example, doesn't have a clear purpose other creating a specific style of a maze. Because the algorithm has no inherent style or theme and is not capable of showing such without extensions, we will merely disregard looking for symmetry, but acknowledge that it's possible to generate mazes that have it.
